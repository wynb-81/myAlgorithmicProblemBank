# 剑指Offer75

## 队列

### 10.2

#### 933.最近的请求次数

==思路==

​	通过队列的FIFO机制，每一次ping都把t放到队列中，然后进行循环判断，如果队列中的元素不在范围内就弹出。

​	第一次写的时候不会，看了一下视频讲解[Leetcode力扣933 手画图解版｜最近的请求次数 Number of Recent Calls_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1gv411b7jW/?spm_id_from=333.337.search-card.all.click&vd_source=9bddb6cb70047b4584618bb96350cf6c)，然后自己写的代码。但是对队列的方法调用也不太熟练。

==实现==

```java
class RecentCounter {
    Queue<Integer> requests = new LinkedList<>();

    public RecentCounter() {
        while(!requests.isEmpty()){
            requests.poll();
        }
    }
    
    public int ping(int t) {
        requests.add(t);
        while(requests.element() < t-3000 || requests.element() >t ){
            requests.poll();
        }
        return requests.size();
    }
}
```

### 11.29

#### 649.Dota2参议院

```java
class Solution {
    public String predictPartyVictory(String senate) {
        char[] s = senate.toCharArray();
        Queue<Integer> r = new LinkedList<>();
        Queue<Integer> d = new LinkedList<>();
        for(int i = 0;i<s.length;i++){
            if(s[i] == 'R'){
                r.add(i);
            }else{
                d.add(i);
            }
        }
        while(!r.isEmpty() && !d.isEmpty()){
            int rIndex = r.poll();
            int dIndex = d.poll();
            if(rIndex < dIndex){
                r.add(rIndex + s.length);
            }else{
                d.add(dIndex + s.length);
            }
        }
        return r.isEmpty() ? "Dire" : "Radiant";
    }
}
```

## 双指针

### 10.17

#### 283.移动零

```java
class Solution {
    public void moveZeroes(int[] nums) {
        /**1.保证非零元素的顺序，我想到的方法就是前后相邻的指针，一个一个往前挪
            这样出现一个问题，如果前后两个都是0的话，那么就会出现前面那个0不动的情况
            **/
        /**2.用前面一个后面一个的话，就无法保证非零元素的顺序，但是可以在把0都弄到后面之后，再采用前后指针的方法，对这几个元素进行排序
            这又出现一个问题，如果后面指针指向的元素是0怎么办？得分太多情况了
            **/    
        //这时应该想一想，反过来做呢？去换非零元素的顺序
        int slow = 0;
        for(int fast = 0;fast<nums.length;fast++){
            if(nums[fast]!=0){
                int temp = nums[slow];
                nums[slow] = nums[fast];
                nums[fast] = temp;
                slow++;
            }
        }
    }
}
```

#### 392.判断子序列

```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        //1.先将两个字符串都转换成数组
        char[] son = s.toCharArray();
        char[] father = t.toCharArray();
        //要比较son是不是father的子序列，那么son就得从第一个元素开始
        //father从第一个元素开始，不同，father++，相同，两个都++
        int slow = 0;
        for(int fast = 0;fast<father.length;fast++){
            if(slow <son.length && father[fast]== son[slow]){
                slow++;
            }
        }
        if(slow == son.length){
            return true;
        }else{
            return false;
        }
    }
}
```

#### 11.盛最多水的容器

```java
class Solution {
    public int maxArea(int[] height) {
        //1.求长方形得面积，因为可能会出现一边高一边低得情况，蓄水就得按低的来算
        //2.快慢指针，一个从0开始，一个从1开始，快的遍历一遍，慢的加1，缺点就是时间复杂度高
        //相当于是两个数组，长度都是n
        // int max = 0;
        // int square = 0;
        // int[] num = new int[height.length];
        // for(int i = 0; i<num.length;i++){
        //     num[i] = i+1;
        // }
        // for(int slow = 0;slow<height.length-1;slow++){
        //     for(int fast = 1;fast<height.length;fast++){
        //         if(height[slow] <= height[fast]){
        //             //这块出现一个问题，fast到最后一个得时候，数组里指向最后一个元素，但是x轴是差一个的
        //             square = height[slow] * (num[fast]-num[slow]);    
        //         }else{
        //             square = height[fast] * (num[fast]-num[slow]);

        //         }
        //         if(square > max){
        //                 max = square;
        //             }
        //     }
        // }
        // return max;
        //这个解法，到一个测试用例的时候，几千个元素的数组，超出了时间限制
        //要存储水多，肯定是x轴和y轴都足够大，但是光这样想，找不到规律
        //参考DP，发现可以先固定x轴，然后挪动小的一个，这样能保证，X轴只会越来越小。而且时间复杂度为O（n）
        int n = height.length -1;  //这个n就是X轴的长度，每挪动一下，-1就好了
        int square = 0;
        int max = 0;
        for(int i = 0 , j = height.length-1;i<=j;){ 
            if(height[i] >= height[j]){
                square = n * height[j];
                j--;
            }else{
                square = n * height[i];
                i++;
            }
            n--;    //每次移动i或者j之后，n都要-1
            if(max < square){
                    max = square;
            }
        }
        return max;
    }
}
```

#### 1679.K和数对得最大数目

```java
class Solution {
    public int maxOperations(int[] nums, int k) {
        //数组不一定是有序的
        //暴力双循环，肯定能解，但是时间复杂度太大
        //如果匹配成功了，那么这两个元素要移出数组，目前的想法是用-1占位
        //不排除有一个元素就大于等于k的情况，那么这个元素直接用-1占位
        // for(int i = 0;i<nums.length-1;){    //时间复杂度超了
        //     for(int j = 1 ;j<nums.length;){
        //         if(nums[j] == -1){
        //             j++;
        //         }
        //         if(nums[i] == -1){
        //             i++;
        //         }else{
        //             if((nums[i] + nums[j])==k){
        //                 nums[i] = -1;
        //                 nums[j] = -1;
        //                 i++;
        //                 j++;
        //                 count++;
        //             }else{
        //                 j++;
        //             }
        //         }
        //     }
        // }
        int count = 0;
        //现在发现，单纯的用快慢指针，会超时
        //先对数组升序排序，然后采用前后快慢指针，如果加一起小了，本回合直接跳过，如果大了，再往前挪
        Arrays.sort(nums);
        for(int i = 0 ,j =nums.length-1;i<j;){
            if((nums[i] + nums[j]) <k){ //i加上最大的都小，i往前挪
                i++;
            }else if((nums[i] + nums[j]) >k){
                j--;
            }else{
                count++;
                i ++;
                j --;
            }
        }
        return count;

    }
}
```

## 字符串

### 10.2

#### 605.种花问题

==思路==

这个感觉自己的解法就是非常的暴力

==实现==

```java
class Solution {
    public boolean canPlaceFlowers(int[] flowerbed, int n) {
        //1.for遍历数组，如果前后都是0，那么这个位置就可以置为1
        //2.for结束之后，看n是否为0了，如果没有，则说明种不完
        //3.需要注意的是只能判断到倒数第二个，倒数第一个需要再判断一下
        int length = flowerbed.length;
        if(length ==1 && flowerbed[0] == 0){
            if(n==0 || n==1){
                return true;
            }

        }else{
            if(flowerbed[0] ==0 && flowerbed[1] ==0){
                n -=1;
                flowerbed[0] = 1;
            }
            if(flowerbed[length-1] == 0 && flowerbed[length -2] ==0){
                n -=1;
                flowerbed[length-1] = 1;
            }
        }
        
        for(int i = 1 ;i <length -1; i++){
            if(flowerbed[i-1] ==0 && flowerbed[i+1]==0){
                if(flowerbed[i]==0){
                    n -= 1;
                    flowerbed[i] = 1;
                }
            }
        }
        if(n <=0){
            return true;
        }else{
            return false;
        }
        
    }
}
```

### 10.9

#### 1071.字符串最大公因子

==思路==

​	首先要判断两个字符串不相等的情况，什么情况下不相等：不满足可交换性

​	然后就通过求最大公约数来截取子字符串

​	这里的难点就是求最大公约数，这个方法我自己不会写，看的deepseek

==实现==

```java
class Solution {
    public String gcdOfStrings(String str1, String str2) {
        if(!(str1 + str2).equals(str2 + str1)){
            return "";
        }
        int gcd = gcdMethod(str1.length(),str2.length());
        return str1.substring(0,gcd);
    }
    private int gcdMethod(int a, int b){
        while(b != 0){
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
}
```

#### 1431.拥有最多糖果的孩子

==思路==

​	1.找出目前拥有糖果最多的那个， 然后看这个人减去额外的糖果，还有几颗
​        2.减去之后剩下的糖果，别的人大于等于这个糖果的，都可以置为true

==实现==

```java
class Solution {
    public List<Boolean> kidsWithCandies(int[] candies, int extraCandies) {
        //1.找出目前拥有糖果最多的那个， 然后看这个人减去额外的糖果，还有几颗
        //2.减去之后剩下的糖果，别的人大于等于这个糖果的，都可以置为true
        int length = candies.length;
        ArrayList<Boolean> result = new ArrayList<>();
        int biggest = 0;
        for(int i =0 ; i<length; i++){
            if(candies[i] > biggest){
                biggest = candies[i];
            }
        }
        int remain = biggest - extraCandies;
        for(int i =0 ; i<length; i++){
            if(candies[i] >= remain){
                result.add(i,true);
            }else{
                result.add(i,false);
            }
        }
        return result;
    }
}
```

### 10.10

#### 345.反转字符串中的元音字母

==思路==

最终还是依靠dp，没想到创建字符串来表示元音字母，然后再去判断。自己一直想用正则表达式了，还有就是switch语句。也想到浪费时间了，但是不知道能怎么整了。

```java
//这个思路写出来的代码，超时了
class Solution {
    public String reverseVowels(String s) {
        //1.从左右两边开始排查，匹配到则换位置，直到左右两边重合或交换了位置
        //问题:正则表达式不能直接匹配char
        //考虑将char数组转换为String类型数组，但是发现不能直接转
        char[] str = s.toCharArray();
        String[] str1 = new String[str.length];
        for(int i = 0;i<str.length;i++){
            str1[i] =String.valueOf(str[i]);
        }
        String temp = "";
        String s1 = "";
        for(int i = 0 , j = str1.length-1; i < str1.length && j >=0;){
            if(i<=j){
                if(str1[i].matches("[aeiouAEIOU]") && str1[j].matches("[aeiouAEIOU]")){
                    temp = str1[i];
                    str1[i] = str1[j];
                    str1[j] = str1[i];
                }else{
                    i++;
                    j--;
                }
                    
            }
        }
        for(int i =0 ; i< str1.length;i++){
            s1.concat(str1[i]);
        } 
        return s1;
    }
}
```

==实现==

```java
class Solution {
    public String reverseVowels(String s) {
        //1.从左右两边开始排查，匹配到则换位置，直到左右两边重合或交换了位置
        //问题:正则表达式不能直接匹配char
        //考虑将char数组转换为String类型数组，但是发现不能直接转
        //写完之后发现超时了，那么想在char转换成String的时候就直接进行比较
        char[] str = s.toCharArray();
        String yy = "aeiouAEIOU";
        int left = 0, right = str.length-1;
        while(left < right){
            while(left < right && yy.indexOf(str[left]) == -1){
                left++;
            }
            while(left < right && yy.indexOf(str[right]) == -1){
                right--;
            }
            if(left<right){
                char temp = str[left];
                str[left] = str[right];
                str[right] = temp;
                left++;
                right--;
            }
        }
        return new String(str);
    }
}
```



### 10.22

#### 151.反转字符串中的单词

自己写的：对于内置函数的使用太多了，往下再写的时候要注意这一点

```java
class Solution {
    public String reverseWords(String s) {
       //1.将字符串转换为数组，转换完之后，会出现有的数组元素是空格的情况
       //2.开始颠倒数组中的元素，每一个元素是一个单词
       //3.颠倒的时候，需要进行判断，如果这个元素是空格，那么就跳过
       String[] result = s.split(" ");
    //    String temp = "";
    //    int begin = 0;
    //    int end = result.length-1;
    //    for(;begin<end;){
    //         if(result[begin] == " "){
    //             begin++;
    //         }
    //         if(result[end] == " "){
    //             end--;
    //         }
    //         if(result[begin] != " " && result[end] != " "){
    //             temp = result[begin];
    //             result[begin] = result[end];
    //             result[end] = temp;
    //             begin++;
    //             end--;
    //         }
    //    }
       //这样交换完之后，result中还存在空格元素，那么再之后拼接的时候就要进行判断，如果是空格元素就跳过
       StringBuilder sb = new StringBuilder();
       for(int i = result.length-1 ;i>=0;){
            if(result[i].equals("")){   //split分割之后，会产生""元素，而不是" "
                i--;
            }else{
                sb.append(result[i]).append(" ");   //最后一个问题，在后面会加一个空格，需要把这个空格去掉
                i--;
            }
        }
        String res = sb.toString();
        return res;
        //超出内存限制，我日
        //突然想到，不交换顺序，直接从后面开始插就行了，试一下超不超内存
        //还是超内存呢
        //超内存的原因是我在else分支里面没写i--
        //最后一个问题就不解决了，因为这个题最主要的是如何手动处理空格？所以准备重写一下


    }
}
```

### 11.5

#### 238.除自身外数组的乘积

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int[] answer = new int[nums.length];    // 先把要返回的数组创建出来
        
        // 方法1：现在循环是n方，超了
        // int j = 0;
        // while(j <nums.length){
        //     for(int i = 0;i<nums.length;i++){
        //         if(i != j){
        //             answer[j] *= nums[i];
        //         }
        //     }
        //     j++;
        // }
        
        //计算左右两边的乘积
        int n = nums.length;
        int[] left = new int[n];
        int[] right = new int[n];
        left[0] = 1;
        right[n-1] = 1;
        for(int i = 1;i<n;i++){
            left[i] = left[i-1] * nums[i-1];
        }
        for(int i = n-2;i>=0;i--){
            right[i] = right[i+1] * nums[i+1];
        }
        for(int i =0;i<n;i++){
            answer[i] = left[i]*right[i];
        }
        return answer;
                
        
    }
}
```

### 334.递增的三元子序列

依旧dp妈的

```java
class Solution {
    public boolean increasingTriplet(int[] nums) {
        // //1.首先选定i
        // //2.先一个循环找j，找到比i大的j了，再从j的位置往后找k
        // for(int i = 0;i<nums.length;i++){
        //     for(int j = i+1;j<nums.length;j++){
        //         if(nums[j] > nums[i]){
        //             for(int k = j+1;k<nums.length;){
        //                 if(nums[k] >nums[j]){
        //                     return true;
        //                 }else{
        //                     k++;
        //                 }
        //             }
        //         }
        //     }
        // }
        // return false;
        //依旧超出时间限制这一块，哈哈
        
        //方法2：选取一个中间元素，然后往两边比较
        //问题：如果比较不成功，元素怎么移动呢？
        //解决：不从中间开始移动，从最左边第二个开始向左移动
        // int left = 0;
        // int right = 0;
        // for(int mid = 1;mid<nums.length;){
        //     for(int i = mid-1;i>=0;i--){
        //         if(nums[i] < nums[mid]){
        //             right = 1;
        //         }
        //     }
        //     for(int j = mid + 1;j<nums.length;j++){
        //         if(nums[j] > nums[mid]){
        //             left = 1;
        //         }
        //     }
        //     if(right ==1 && left ==1){
        //         return true;
        //     }else{
        //         mid++;
        //         left = 0;   //之前忘记重置这两个值，导致用例[5,1,6]的时候，mid+了，然后left那时候已经是1了，right一变1就返回true了
        //         right = 0;
        //     }
        // }
        // return false;
        //依旧用例77超过时间限制

        if (nums == null || nums.length < 3) {
            return false;
        }
        
        int first = Integer.MAX_VALUE;
        int second = Integer.MAX_VALUE;
        
        for (int num : nums) {
            if (num <= first) {
                // 更新最小的候选值
                first = num;
            } else if (num <= second) {
                // 更新第二小的候选值
                second = num;
            } else {
                // 找到比 second 大的数，构成三元组
                return true;
            }
        }
        
        return false;
    }
}
```

### 11.10

#### 443.压缩字符串

用的deepseek，我发现一个事情就是会用到很多库函数，如果面试官要求手动写，自己也得会，因此第二遍刷的时候，自己就应该先写一遍之前会的方法，然后再把其中的库函数看看能不能手动实现

```java
class Solution {
    public int compress(char[] chars) {
        int n = chars.length;
        // 写指针，指向当前要写入的位置
        int write = 0;
        // 读指针，用于遍历数组
        int read = 0;

        while (read < n) {
            // 当前要处理的字符
            char currentChar = chars[read];
            // 统计该字符连续出现的次数
            int count = 0;
            // 注意：这里 read < n 的判断要放在前面，防止数组越界
            while (read < n && chars[read] == currentChar) {
                read++;
                count++;
            }

            // 1. 写入字符
            chars[write++] = currentChar;

            // 2. 如果计数大于1，写入数字
            if (count > 1) {
                // 将计数转换成字符串，然后逐个写入数字字符
                // 例如 count = 12 -> "12" -> ['1','2']
                for (char c : Integer.toString(count).toCharArray()) {
                    chars[write++] = c;
                }
            }
        }
        // 写指针的最终位置就是新数组的长度
        return write;
    }
}
```

## 滑动窗口

### 11.11

#### 643.子数组最大平均数I

```java
class Solution {
    public double findMaxAverage(int[] nums, int k) {
        int sum = 0;
        for(int i = 0;i<k;i++){
            sum +=nums[i];
        }
        int maxSum = sum;
        for(int i = k;i<nums.length;i++){
            sum = sum-nums[i-k]+nums[i];
            if(sum > maxSum){
                maxSum = sum;
            }
        }
        return (double)maxSum/k;
    }
}
```

#### 1456.定长字串中元音的最大数目

```java
class Solution {
    public int maxVowels(String s, int k) {
        //超出时间限制
        char[] chars = s.toCharArray();
        int sum = 0;
        int maxSum = 0;
        for(int i = 0;i<k;i++){
            switch(chars[i]){
                case 'a':
                    sum +=1;
                    break;
                case 'e':
                    sum +=1;
                    break;
                case 'i':
                    sum +=1;
                    break;
                case 'o':
                    sum +=1;
                    break;
                case 'u':
                    sum +=1;
                    break;
            }
        }
        maxSum = sum;
        for(int i = k ;i<chars.length;i++){
            switch(chars[i-k]){
                case 'a':
                    sum -=1;
                    break;
                case 'e':
                    sum -=1;
                    break;
                case 'i':
                    sum -=1;
                    break;
                case 'o':
                    sum -=1;
                    break;
                case 'u':
                    sum -=1;
                    break;
            }
            switch(chars[i]){
                case 'a':
                    sum +=1;
                    break;
                case 'e':
                    sum +=1;
                    break;
                case 'i':
                    sum +=1;
                    break;
                case 'o':
                    sum +=1;
                    break;
                case 'u':
                    sum +=1;
                    break;
            }
            if(maxSum <sum){
                maxSum = sum;
            }
        }
        return maxSum;
    }
}
```

### 11.12

#### 1493.

```java
class Solution {
    public int longestSubarray(int[] nums) {
        //必须删除掉其中一个元素
        //左右两个指针
        int sum = 0;
        int max = 0;
        int zero = 0;
        int j = 0;
        for(int i = 0;i<nums.length;i++){
            if(nums[i] == 0){
                zero++;
            }
            while(zero >1){
                if(nums[j] ==0){
                    zero--;
                }
                j++;
            }
            sum = i-j;
            if(sum > max){
                max = sum;
            }
        }
        return max;
    }
}
```

#### 1004.

```java
class Solution {
    public int longestOnes(int[] nums, int k) {
        int left = 0;
        int zero = 0;
        int sum = 0;
        int max = 0;
        for(int right = 0;right<nums.length;){
            if(nums[right] == 0){
                zero ++;
            }
            while(zero > k){
                if(nums[left] == 0){
                    zero--;
                }
                left++;
                
            }
            sum = right-left+1;
            if(sum > max){
                max = sum;
            }
            right++;
        }
        if(zero < k){
            return nums.length;
        }
        return max;
    }
}
```

## 哈希表

### 11.29

#### 2215.找出两组数的不同

```java
class Solution {
    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {
        List<List<Integer>> answer = new ArrayList<>();        
        Set<Integer> set1 = new HashSet<>();
        Set<Integer> set2 = new HashSet<>();
        for(int i : nums1){
            set1.add(i);
        }
        for(int i : nums2){
            set2.add(i);
        }
        List<Integer> list1 = new ArrayList<>();
        for(int i : set1){
            if(!set2.contains(i)){
                list1.add(i);
            }
        }
        List<Integer> list2 = new ArrayList<>();
        for(int i : set2){
            if(!set1.contains(i)){
                list2.add(i);
            }
        }
        answer.add(list1);
        answer.add(list2);

        return answer;
    }
}
```

#### 1207.独一无二的出现次数

```java
class Solution {
    public boolean uniqueOccurrences(int[] arr) {
        //1.创建一个hashset，往里面添加遍历的次数，如果有重复，会添加失败
        Set<Integer> answer = new HashSet<>();
        int count = 1;
        Arrays.sort(arr);
        //应该给已经加过的数做一个标记，防止之后遍历的时候，还把它查一次，那还是先对数组进行一下排序比较好.然后直接将i至于j的位置就行了
        for(int i = 1;i<arr.length;i++){
                if(arr[i] == arr[i-1]){
                    count++;
                }else{
                    if(!answer.add(count)){
                        return false;
                    }
                    count = 1;
                }
            
        }
        return answer.add(count);
            
    }
}
```

## 栈

### 11.29

#### 2390.从字符串中移除星号

```java
class Solution {
    public String removeStars(String s) {
        Stack<Character>  temp = new Stack<>();
        char[] result = s.toCharArray();
        for(int i = 0;i<result.length;i++){
            if(result[i] != '*'){
                temp.push(result[i]);
            }else{
                temp.pop();
            }
        }
        StringBuilder sb = new StringBuilder();
        while(!temp.isEmpty()){
            sb.append(temp.pop());
        }
        return sb.reverse().toString(); //这个reverse方法，能不能自己给写出来？手动实现字符串反转，因为从栈中出来顺序是反的。
                                        //现在对于这块我很迷茫，不知道现在这样是否属于过度依赖Java现成的工具来解决算法题？
    }
}
```

